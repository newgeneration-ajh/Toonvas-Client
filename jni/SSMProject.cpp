//2013. 11. 1 ~ 2013. 1. 31(3揶쏆뮇�� - 30/50
//23-1疫뀐옙占쎈뜃由곤옙占�//占쎄낯湲쏙㎗�롡봺(opencv)�쒙옙占쎈똻�쒙옙占쏙옙��쀯옙占쏙옙袁り숲 �닌뗭겱 獄쏉옙占썬끆�몌옙占썹빊遺욱뀱
//1 -> 3
//燁살눖�� 占쎈쵎媛�占썩돦��占쎌빘苑�- �닌뗭겱
//占썩돦��占쎌뮄援�- �닌뗭겱
//�믪눘占쏙옙占쏙옙�쎄쾿占쎌꼷��- 沃섎㈇�꾬옙占�//2 -> 2
//占쎈슣已�占쎈슢�낉옙占� 沃섎㈇�꾬옙占�//鈺곌퀡梨몌옙�ｋ궢 - �닌뗭겱
//3 -> 7
//揶쏉옙�ｏ옙癒�봺 揶쏅벡��- �닌뗭겱
//揶쏄낯彛딉옙占� 沃섎㈇�꾬옙占�//域밸챶窺占쏙옙- �닌뗭겱
//占쎈�紐�옙占쏙옙占� 沃섎㈇�꾬옙占�//占쎈맪寃�占썬끆�몌옙占� 沃섎㈇�꾬옙占�//�됰슢�곫묾占� 沃섎㈇�꾬옙占�//占썬끋遊쏙옙�됱뵠 占썬끋�껅에占� 沃섎㈇�꾬옙占�//4 -> 4
//占쎌쥙萸끾에占쎌쓺 - �닌뗭겱
//占쏙옙占쎌쥙萸끾에占쎌쓺 - �닌뗭겱
//占쎈챷源띰옙袁⑤뻼 筌띾뜆�わ옙占� �닌뗭겱
//揶쏉옙�ｏ옙癒�봺 占쎌쥓梨몌옙�띿쓺 - �닌뗭겱
//5 -> 7
//域밸챶�믭옙占쏙옙�뽰뱽 �닌뗭겱占쎌꼵由�占쎄쑵釉�占썩돦��- �닌뗭겱
//域밸챶�믭옙占쏙옙占� �닌뗭겱
// 占쏙옙占썼�占쏙옙�ｋ궢 - �닌뗭겱
//占쎌꼹遊쏙옙占쏙옙�ｋ궢 - �닌뗭겱
//癰귣벊沅�占썩몿��- �닌뗭겱
//�얠눘伊뚳옙占쏙옙�ｋ궢 - 沃섎㈇�꾬옙占�//�브쑵釉섉�占쏙쭗�브퉪 - 沃섎㈇�꾬옙占�//6 -> 6
//占쎈벡沅�- �닌뗭겱
//占쎌쥓�ワ옙占� �닌뗭겱
//揶쏉옙�ｏ옙癒�봺 筌≪뼐由�- �닌뗭겱
//�⑥눖占쏙옙紐꾪뀱 - �닌뗭겱
//占썬끆�몌옙占썹빊遺우읅 - 沃섎㈇�꾬옙占�//獄쏅뗀��占썩몿��- 沃섎㈇�꾬옙占�//7 -> 10
//占쎈맩肉곤옙占� �닌뗭겱
//占쎌뮆�わ옙占썽뇡��쑎占쏙옙- 沃섎㈇�꾬옙占�//占쎄쑬已�域밸챶�낉옙占� �닌뗭겱
//占썬끉�⒵꽴占� 沃섎㈇�꾬옙占�//獄쏅뗀�ㅶ묾占� �닌뗭겱
//占쎈뗀�낉옙占쏙옙�륁뵠占쏙옙- 沃섎㈇�꾬옙占�//椰꾧퀣��占쎈슣�わ옙占� 沃섎㈇�꾬옙占�//�얜챷占썹몴占쏙옙�ｋ궢 - 沃섎㈇�꾬옙占�//占쎈챶�묕옙�륁뵥占쏙옙- 沃섎㈇�꾬옙占�//占쎌꼷肄덌옙占� �닌뗭겱
//8 -> 5
//域밸챶�낉옙占쏙옙�ｋ궢 - �닌뗭겱
//筌뤴뫁�꾬옙�꾧쾿 占썩몿��- �닌뗭겱
//占썩뫁�귨옙占쏙옙�ｋ궢 - �닌뗭겱
//域뱀쥙肉�- 沃섎㈇�꾬옙占�//占쎈씮�わ㎗�묒넅 - 沃섎㈇�꾬옙占�//9 -> 5
//占쎈Ŧ�곩칰占� �닌뗭겱
//占쏙옙占쎈Ŧ�곩칰占� �닌뗭겱
//揶쏉옙��옙�뽯툧 占쎈Ŧ��- �닌뗭겱
//占쏙옙彛낉옙��뮉 占썩몿��- �닌뗭겱
//占쎈���占쎈Ŧ��占썩몿��- 沃섎㈇�꾬옙占�//10 -> 1
//占썬끆�몌옙占썹빊遺욱뀱 - �닌뗭겱

#include <jni.h>
#include <iostream>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <vector>

using namespace std;
using namespace cv;

extern "C"{
	///////////////////////////////////////////////////////
	/////////////////        1        /////////////////////
	///////////////////////////////////////////////////////

	//占썩돦���곕떽占�
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_addNoise(JNIEnv* env, jobject thiz, jlong addrImage, jint value)
	{
		Mat& mat  = *((Mat*)addrImage);

		time_t t;
		srand(time(&t));

		jboolean* imageData = (jboolean*)mat.data;
		jboolean data = 0;

		jint imageSize = mat.cols * mat.rows;
		jint step = mat.step;

		jint rHeight = 0, rWidth = 0;

		jdouble rVal1 = 0.0, rVal2 = 0.0;
		jdouble noise = 0.0;
		jdouble std = 40;
		jdouble temp;

		while(imageSize>0)
		{
			rHeight = rand()%mat.rows;
			rWidth = rand()%mat.step;

			rVal1 = (jdouble)rand()/RAND_MAX;
			rVal2 = (jdouble)rand()/RAND_MAX;

			noise = sqrt(-1.0*value*log(rVal1))*cos(value*3.14159*rVal2);
			noise *= std;

			temp = imageData[rHeight*step+rWidth]+noise;

			if(temp<0)
			{
				data = 255;
			}
			else if (temp>255)
			{
				data = 0;
			}
			else
			{
				data = (jboolean)(*imageData);
			}

			imageData[rHeight*step+rWidth] = data;

			imageSize--;
		}
	}

	//占쎈챷�좑쭩占쏙옙�볤탢
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_noiseBlur(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		GaussianBlur(mat, mat, Size(15, 15), 0, 0);
	}

	///////////////////////////////////////////////////////
	/////////////////        2        /////////////////////
	///////////////////////////////////////////////////////

	//鈺곌퀡梨몌옙�ｋ궢 - �닌뗭겱
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_lighting(JNIEnv* env, jobject thiz, jlong addrImage, jint xValue, jint yValue, jint radius)
	{
		Mat& mat  = *((Mat*)addrImage);

		int height = mat.rows;
		int width = mat.cols;
		int py = xValue;	//癰귨옙��
		int px = yValue;	//癰귨옙��
		int r = radius;		//癰귨옙��

		mat -= Scalar(100, 100, 100);

		for(int i=0;i<height;i++)
		{
			for(int j= 0;j<width;j++)
			{
				if((j-px)*(j-px)+(i-py)*(i-py) <= r*r)
				{
					mat.at<Vec3b>(i,j) += Vec3b(100,100,100);
				}
			}
		}
	}

	///////////////////////////////////////////////////////
	/////////////////        3        /////////////////////
	///////////////////////////////////////////////////////

	//揶쏉옙�ｏ옙癒�봺 揶쏅벡��
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_accentedEdges(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		cvtColor(mat, mat, CV_BGRA2BGR);

		Mat element = getStructuringElement(MORPH_RECT, Size(3, 3), Point(1, 1));
		Mat erodeImage(mat.rows, mat.cols, CV_8U);
		Mat dilateImage(mat.rows, mat.cols, CV_8U);

		dilate(mat, dilateImage, element);
		erode(mat, erodeImage, element);

		subtract(dilateImage, erodeImage, mat);

		element.release();
		erodeImage.release();
		dilateImage.release();
	}

	//域밸챶窺占쏙옙- 揶쏉옙以�占쎈챶以�hatch �닌뗭겱
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_crosshatch(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		double sMask[3][3] = {
			{-1, -1, -1},
			{-1, 9, -1},
			{-1, -1, -1},
		};

		Mat sharpImage1(mat.rows, mat.cols, CV_8U);
		Mat blurImage1(mat.rows, mat.cols, CV_8U);
		Mat sharpImage2(mat.rows, mat.cols, CV_8U);
		Mat blurImage2(mat.rows, mat.cols, CV_8U);

		Mat kernel = Mat(3, 3, CV_64FC1, Scalar(0));

		for(int i=0;i<3;i++)
		{
			for(int j=0;j<3;j++)
			{
				kernel.at<double>(i,j) = sMask[i][j];
			}
		}

		filter2D(mat, sharpImage1, mat.depth(), kernel);

		GaussianBlur(sharpImage1, sharpImage1, Size(21, 3), 20, 3);

		filter2D(sharpImage1, sharpImage1, sharpImage1.depth(), kernel);

		filter2D(mat, sharpImage2, mat.depth(), kernel);

		GaussianBlur(sharpImage2, sharpImage2, Size(3, 21), 3, 20);

		filter2D(sharpImage2, sharpImage2, sharpImage2.depth(), kernel);

		addWeighted(sharpImage1, 0.5, sharpImage2, 0.5, 0, mat);

		sharpImage1.release();
		sharpImage2.release();
	}

	///////////////////////////////////////////////////////
	/////////////////        4        /////////////////////
	///////////////////////////////////////////////////////

	//占쎌쥓梨몌옙�띿쓺
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_laplacianSharp(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		jdouble mask[3][3] = {{0.0, -1.0, 0.0}, {-1.0, 5.0, -1.0}, {0.0, -1.0, 0.0}};

		Mat kernel = Mat(3, 3, CV_64FC1, Scalar(0));

		for(int i=0;i<3;i++)
		{
			for(int j=0;j<3;j++)
			{
				kernel.at<double>(i,j) = mask[i][j];
			}
		}
		filter2D(mat, mat, mat.depth(), kernel);
	}

	//占쏙옙占쎌쥓梨몌옙�띿쓺
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_moreLaplacianSharp(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		jdouble mask[3][3] = {{1.0, 1.0, 1.0}, {1.0, -7.0, 1.0}, {1.0, 1.0, 1.0}};
		//{{-1.0, -1.0, -1.0}, {-1.0, 9.0, -1.0}, {-1.0, -1.0, -1.0}};

		Mat kernel = Mat(3, 3, CV_64FC1, Scalar(0));

		for(int i=0;i<3;i++)
		{
			for(int j=0;j<3;j++)
			{
				kernel.at<double>(i,j) = mask[i][j];
			}
		}
		filter2D(mat, mat, mat.depth(), kernel);
	}

	//占쎈챷源띰옙袁⑤뻼
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_unsharpening(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		Mat destImage(mat.rows, mat.cols, CV_8U);
		Mat diffImage(mat.rows, mat.cols, CV_8U);

		jint height = mat.rows;
		jint width = mat.cols;

		blur(mat, destImage, Size(9, 9));

		Vec3b tmpDiff(0, 0, 0);
		Vec3b tmpUnsharp(0, 0, 0);

		for(int j=0;j<height;j++)
		{
			for(int i=0;i<width;i++)
			{
				mat.at<Vec3b>(j, i) = mat.at<Vec3b>(j, i) - destImage.at<Vec3b>(j, i) + Vec3b(128, 128, 128);
			}
		}

		for(int j=0; j<height; j++)
		{
			for(int i=0; i<width; i++)
			{
				mat.at<Vec3b>(j, i).val[0] = destImage.at<Vec3b>(j, i).val[0] + (mat.at<Vec3b>(j, i).val[0] - 128) * 0.5;
				mat.at<Vec3b>(j, i).val[1] = destImage.at<Vec3b>(j, i).val[1] + (mat.at<Vec3b>(j, i).val[1] - 128) * 0.5;
				mat.at<Vec3b>(j, i).val[2] = destImage.at<Vec3b>(j, i).val[2] + (mat.at<Vec3b>(j, i).val[2] - 128) * 0.5;
			}
		}
	}

	//揶쏉옙�ｏ옙癒�봺 占쎌쥓梨몌옙�띿쓺 - �닌뗭겱
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_sharpenEdge(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);
		jdouble mask[3][3] = {{1.0, -2.0, 1.0}, {-2.0, 5.0, -2.0}, {1.0, -2.0, 1.0}};

		Mat kernel = Mat(3, 3, CV_64FC1, Scalar(0));

		for(int i=0;i<3;i++)
		{
			for(int j=0;j<3;j++)
			{
				kernel.at<double>(i,j) = mask[i][j];
			}
		}
		filter2D(mat, mat, mat.depth(), kernel);
	}

	///////////////////////////////////////////////////////
	/////////////////         5       /////////////////////
	///////////////////////////////////////////////////////

	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_sketchNoise(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		time_t t;
		srand(time(&t));

		jboolean* imageData = (jboolean*)mat.data;
		jboolean data = 0;

		jint imageSize = mat.cols * mat.rows;
		jint step = mat.step;

		jint rHeight = 0, rWidth = 0;

		jdouble rVal1 = 0.0, rVal2 = 0.0;
		jdouble noise = 0.0;
		jdouble std = 40;
		jdouble temp;

		while(imageSize>0)
		{
			rHeight = rand()%mat.rows;
			rWidth = rand()%mat.step;

			rVal1 = (jdouble)rand()/RAND_MAX;
			rVal2 = (jdouble)rand()/RAND_MAX;

			noise = sqrt(-2.0*log(rVal1))*cos(2*3.14159*rVal2);
			noise *= std;

			temp = imageData[rHeight*step+rWidth]+noise;

			if(temp<0)
			{
				data = 255;
			}
			else if (temp>255)
			{
				data = 0;
			}
			else
			{
				data = (jboolean)(*imageData);
			}

			imageData[rHeight*step+rWidth-0]=data;
			imageData[rHeight*step+rWidth-2]=data;
			imageData[rHeight*step+rWidth-4]=data;
			imageData[rHeight*step+rWidth-6]=data;
			imageData[rHeight*step+rWidth-8]=data;

			imageSize-=75;
		}
	}

	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_graphicPenSketch(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		if(3 == mat.channels())
		{
			mat.convertTo(mat, CV_8UC1);
			cvtColor(mat, mat, CV_BGRA2GRAY);
		}

		threshold(mat, mat, 80, 255, CV_THRESH_BINARY);

		time_t t;
		srand(time(&t));

		jboolean* imageData = (jboolean*)mat.data;
		jboolean data = 0;

		jint imageSize = mat.cols * mat.rows;
		jint step = mat.step;

		jint rHeight = 0, rWidth = 0;

		jdouble rVal1 = 0.0, rVal2 = 0.0;
		jdouble noise = 0.0;
		jdouble std = 40;
		jdouble temp;

		while(imageSize>0)
		{
			rHeight = rand()%mat.rows;
			rWidth = rand()%mat.step;

			rVal1 = (jdouble)rand()/RAND_MAX;
			rVal2 = (jdouble)rand()/RAND_MAX;

			noise = sqrt(-2.0*log(rVal1))*cos(2*3.14159*rVal2);
			noise *= std;

			temp = imageData[rHeight*step+rWidth]+noise;

			if(temp<0)
			{
				data = 255;
			}
			else if (temp>255)
			{
				data = 0;
			}
			else
			{
				data = (jboolean)(*imageData);
			}

			imageData[rHeight*step+rWidth-0]=data;
			imageData[rHeight*step+rWidth-2]=data;
			imageData[rHeight*step+rWidth-4]=data;
			imageData[rHeight*step+rWidth-6]=data;
			imageData[rHeight*step+rWidth-8]=data;

			imageSize -= 75;
		}
	}

	//占쏙옙占썼�占쏙옙�ｋ궢
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_basRelief(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		Mat tempImage(mat.rows, mat.cols, CV_8UC1);

		if(3 == mat.channels())
		{
			cvtColor(mat, tempImage, CV_BGRA2GRAY);
		}else{
			tempImage = mat.clone();
		}

		double maskNorthEast[3][3] = {{0.0f, -1.0f, -2.0f}, {1.0f, 0.0f, -1.0f}, {2.0f, 1.0f, 0.0f}};
		Mat kernel = Mat(3, 3, CV_64FC1, Scalar(0));

		for(int i=0;i<3;i++)
		{
			for(int j=0;j<3;j++)
			{
				kernel.at<double>(i,j) = maskNorthEast[i][j];
			}
		}

		Scalar average = mean(tempImage);

		filter2D(tempImage, tempImage, tempImage.depth(), kernel);

		mat = tempImage.clone();
		add(tempImage, average, mat);
	}

	//占쎌꼹遊쏙옙占쏙옙�ｋ궢
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_halfTon(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		cvtColor(mat, mat, CV_BGRA2BGR);

		Vec3b scalar2 = Vec3b(0, 0, 0);
		Vec3b f[4];

		jint height = mat.rows;
		jint width = mat.step1()/3;
		jint value = 0, valueOut = 0, diffValue = 0;
		jdouble diff[4] = {0, 0, 0, 0};

		for(int i=0;i<4;i++)
		{
			f[i] = Vec3b(0, 0, 0);
		}

		blur(mat, mat, Size(3, 3));

		for(int i=0;i<height-1;i++)
		{
			for(int j=1;j<width-1;j++)
			{
				Vec3b scalar = mat.at<Vec3b>(i, j);

				value = (scalar.val[0] + scalar.val[1] + scalar.val[2]) / 3;

				if(value<128){
					valueOut = 0;
				}else
				{
					valueOut = 255;
				}
				scalar2 = Vec3b(valueOut, valueOut, valueOut);

				mat.at<Vec3b>(i, j) = scalar2;

				diffValue = value - valueOut;
				f[0] = mat.at<Vec3b>(i, j+1);
				f[1] = mat.at<Vec3b>(i+1, j-1);
				f[2] = mat.at<Vec3b>(i+1, j);
				f[3] = mat.at<Vec3b>(i+1, j+1);

				diff[0] = diffValue * 7/16;
				diff[1] = diffValue * 3/16;
				diff[2] = diffValue * 5/16;
				diff[3] = diffValue * 1/16;

				f[0] += Vec3b(diff[0], diff[0], diff[0]);
				f[1] += Vec3b(diff[1], diff[1], diff[1]);
				f[2] += Vec3b(diff[2], diff[2], diff[2]);
				f[3] += Vec3b(diff[3], diff[3], diff[3]);

				mat.at<Vec3b>(i, j+1) = f[0];
				mat.at<Vec3b>(i+1, j-1) = f[1];
				mat.at<Vec3b>(i+1, j) =  f[2];
				mat.at<Vec3b>(i+1, j+1) =  f[3];
			}
		}
	}

	//癰귣벊沅�占썩몿��
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_photoCopy(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);
		Mat grayImage(mat.rows, mat.cols, CV_8UC1);

		jint width = mat.cols;
		jint height = mat.rows;

		mat.convertTo(mat, CV_8UC1);
		cvtColor(mat, mat, CV_BGRA2GRAY);
		grayImage = mat.clone();

		adaptiveThreshold(grayImage, mat, 255, CV_ADAPTIVE_THRESH_MEAN_C, CV_THRESH_BINARY, 21, 10);
	}

	///////////////////////////////////////////////////////
	/////////////////        6        /////////////////////
	///////////////////////////////////////////////////////

	//占쎈벡沅�- bilateral filter
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_diffuse(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);
		Mat destImage(mat.rows, mat.cols, CV_8U);

		cvtColor(mat, mat, CV_BGRA2BGR);

		bilateralFilter(mat, destImage, 0, 71, 3);

		mat = destImage.clone();
	}

	//占쎌쥓�ワ옙占�
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_emboss(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);
		float mask[3][3] = {
			{-1.0f, 0.0f, 0.0f},
			{0.0f, 0.0f, 0.0f},
			{0.0f, 0.0f, 1.0f}
		};

		if(3 == mat.channels())
		{
			mat.convertTo(mat, CV_8UC1);
			cvtColor(mat, mat, CV_BGRA2GRAY);
		}

		Mat kernel(3, 3, CV_32FC1, mask);

		Scalar average = mean(mat);

		filter2D(mat, mat, mat.depth(), kernel);

		add(mat, average, mat);
	}

	//揶쏉옙�ｏ옙癒�봺 筌≪뼐由�- �닌뗭겱
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_findEdges(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		cvtColor(mat, mat, CV_BGRA2BGR);

		float mask[3][3] = {
			{1.0f, 1.0f, 1.0f},
			{1.0f, -8.0f, 1.0f},
			{1.0f, 1.0f, 1.0f}
		};

		Mat kernel(3, 3, CV_64FC1, mask);

		filter2D(mat, mat, mat.depth(), kernel);

		bitwise_not(mat, mat);

	}

	//�⑥눖占쏙옙紐꾪뀱 - �닌뗭겱
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_solarize(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		cvtColor(mat, mat, CV_BGRA2BGR);

		bitwise_not(mat, mat);
	}

	///////////////////////////////////////////////////////
	/////////////////        7        /////////////////////
	///////////////////////////////////////////////////////

	//占쎈맩肉곤옙占� 沃섎㈇�꾬옙占�
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_colorPencil(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		Mat grayImage(mat.rows, mat.cols, CV_8UC1);
		Mat destImage(mat.rows, mat.cols, CV_8U);
		Mat invertImage(mat.rows, mat.cols, CV_8U);
		Mat smoothImage(mat.rows, mat.cols, CV_8U);

		uchar b_1, g_1, r_1, b_2, g_2, r_2, b_d, g_d, r_d;

		bitwise_not(mat, invertImage);
		GaussianBlur(mat, smoothImage, Size(7, 7), 0, 0);

		add(invertImage, smoothImage, destImage);

		cvtColor(destImage, grayImage, CV_BGRA2GRAY);

		addWeighted(destImage, 0.3, mat, 0.7, 0, mat);
	}

	//占쎄쑬已�域밸챶�낉옙占� �닌뗭겱
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_filmGrain(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);
		time_t t;
		srand(time(&t));

		cvtColor(mat, mat, CV_BGRA2GRAY);

		if(3 == mat.channels())
		{
			mat.convertTo(mat, CV_8UC1);
			cvtColor(mat, mat, CV_BGRA2GRAY);
		}

		double noiseRange = 0.3;//癰귨옙��
		double randValue = 0.0;
		double var = 0.0, preGauss = 0.0, gauss = 0.0;
		double retVal = 0.0;
		double pi = 3.141592654;
		double EPSILON = 0.000001;
		unsigned char* data = (unsigned char*)mat.data;

		int height = mat.rows;
		int width = mat.cols;

		for(int i=0;i<height;i++)
		{
			for(int j=0;j<width;j++)
			{
				randValue = rand() / (RAND_MAX + 1.0);
				preGauss = randValue <= EPSILON ? 255.0:sqrt(-2.0 * log(randValue));

				randValue = rand() / (RAND_MAX + 1.0);
				gauss = preGauss * cos(2.0*pi*randValue);
				var = 0.5 + (double)data[i + j] + (double)data[i + j] * noiseRange*gauss;

				if(var > 255)
				{
					retVal = 255;
				}
				else if(var < 0)
				{
					retVal = 0;
				}
				else
				{
					retVal = var;
				}

				data[i + j] =  retVal;
			}
		}
	}

	//獄쏅뗀�ㅶ묾占� �닌뗭겱
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_paintDaub(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		dilate(mat, mat, 0, Point(-1, -1), 4);
		erode(mat, mat, 0, Point(-1, -1), 4);
	}

	//占쎌꼷肄덌옙占�
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_watercolor(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		jdouble mask[3][3] = {{0.0, -1.0, 0.0}, {-1.0, 5.0, -1.0}, {0.0, -1.0, 0.0}};

		Mat kernel = Mat(3, 3, CV_64FC1, mask);

		mat += Scalar(60,60,60);

		medianBlur(mat, mat, 5);
		medianBlur(mat, mat, 5);
		medianBlur(mat, mat, 5);
		medianBlur(mat, mat, 5);

		filter2D(mat, mat, mat.depth(), kernel);
	}

	///////////////////////////////////////////////////////
	/////////////////        8        /////////////////////
	///////////////////////////////////////////////////////

	//域밸챶�낉옙占쏙옙�ｋ궢
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_grain(JNIEnv* env, jobject thiz, jlong addrImage, jint value)
	{
		Mat& mat  = *((Mat*)addrImage);

		blur(mat, mat, Size(5, 5), Point(0, 0));

		time_t t;
		srand(time(&t));

		jboolean* imageData = (jboolean*)mat.data;
		jboolean data = 0;

		jint imageSize = mat.cols * mat.rows;
		jint step = mat.step1();

		jint rHeight = 0, rWidth = 0;

		jdouble rVal1 = 0.0, rVal2 = 0.0;
		jdouble noise = 0.0;
		jdouble std = 40;
		jdouble temp;

		while(imageSize>0)
		{
			rHeight = rand()%mat.rows;
			rWidth = rand()%mat.step;

			rVal1 = (jdouble)rand()/RAND_MAX;
			rVal2 = (jdouble)rand()/RAND_MAX;

			noise = sqrt(-1.0*value*log(rVal1))*cos(value*3.14159*rVal2);
			noise *= std;

			temp = imageData[rHeight*step+rWidth]+noise;

			if(temp<0)
			{
				data = 255;
			}
			else if (temp>255)
			{
				data = 0;
			}
			else
			{
				data = (jboolean)(*imageData);
			}

			imageData[rHeight*step+rWidth] = data;

			imageSize--;
		}
	}

	//筌뤴뫁�꾬옙�꾧쾿 占썩몿��value = 13
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_mosaicTiles(JNIEnv* env, jobject thiz, jlong addrImage, jint value)
	{
		Mat& mat  = *((Mat*)addrImage);

		cvtColor(mat, mat, CV_BGRA2BGR);

		jboolean* data = (jboolean*)mat.data;
		jint count = 0;
		jint width = mat.cols;
		jint height = mat.rows;
		jint step = mat.step;
		jint moWidth = value, moHeight = value;
		jint red = 0, blue = 0, green = 0;
		jint i = 0, j = 0, x = 0, y = 0;

		for(i=0;i<height;i+=value)
		{
			for(j=0;j<width;j+=value)
			{
				count = 0;
				red = 0; green = 0; blue = 0;

				if((i+value) > height)
				{
					moHeight = height % value;
				}
				else
				{
					moHeight = value;
				}

				if((j+value) > width)
				{
					moWidth = width % value;
				}
				else
				{
					moWidth = value;
				}

				for(x=0;x<moHeight;x++)
				{
					for(y=0;y<moWidth;y++)
					{
						blue += data[3*(j+y)+(i+x)*step];
						green += data[3*(j+y)+(i+x)*step+1];
						red += data[3*(j+y)+(i+x)*step+2];
						count++;
					}
				}

				blue /= count;
				green /= count;
				red /= count;

				for(x=0;x<moHeight;x++)
				{
					for(y=0;y<moWidth;y++)
					{
						data[3*(j+y)+(i+x)*step] = (jboolean)blue;
						data[3*(j+y)+(i+x)*step+1] = (jboolean)green;
						data[3*(j+y)+(i+x)*step+2] = (jboolean)red;
					}
				}
			}
		}
	}

	//占썩뫁�귨옙占�
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_patchWork(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		cvtColor(mat, mat, CV_BGRA2BGR);

		jint width = mat.cols;
		jint height = mat.rows;
		jint step = mat.step;
		jboolean* data = (jboolean*)mat.data;
		jint i = 0, j = 0;

		for(i=0;i<height;i+=10)
		{
			for(j=0;j<width;j+=10)
			{
				rectangle(mat, cvPoint(j,i), cvPoint(j+50,i+50), CV_RGB(data[i*step+j*3+2],data[i*step+j*3+1],data[i*step+j*3+0]),10);
			}
		}
	}


	///////////////////////////////////////////////////////
	/////////////////        9        /////////////////////
	///////////////////////////////////////////////////////

	//占쎈Ŧ�곩칰占쏙옙�ｋ궢
	JNIEXPORT void Java_com_secmem_spentest2_canvas_CanvasActivity_blur(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		blur(mat, mat, Size(5, 5), Point(0, 0));
	}

	//占쏙옙占쎈Ŧ�곩칰占쏙옙�ｋ궢 - 占쎈Ŧ�곩칰占쏙옙�ｋ궢 4占쏙옙餓λ쵐爰�
	JNIEXPORT void Java_com_secmem_spentest2_canvas_CanvasActivity_moreBlur(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		blur(mat, mat, Size(5, 5), Point(0, 0));
		blur(mat, mat, Size(5, 5), Point(0, 0));
		blur(mat, mat, Size(5, 5), Point(0, 0));
		blur(mat, mat, Size(5, 5), Point(0, 0));
	}

	//揶쏉옙��옙�뽯툧 �됰뗀��占썩몿��
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_gaussianBlur(JNIEnv* env, jobject thiz, jlong addrImage, jint sigma)
	{
		Mat& mat  = *((Mat*)addrImage);

		cv::GaussianBlur(mat, mat, Size(5, 5), sigma);
	}

	//占쏙옙彛낉옙��뮉 占썩몿��- �닌뗭겱
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_motionBlur(JNIEnv* env, jobject thiz, jlong addrImage, jint value)
	{
		Mat& mat  = *((Mat*)addrImage);

		switch(value){
			case 0:
				GaussianBlur(mat, mat, Size(11, 3), 80, 3);
				break;
			case 1:
				GaussianBlur(mat, mat, Size(3, 11), 80, 3);
				break;
		}
	}

	///////////////////////////////////////////////////////
	/////////////////        10       /////////////////////
	///////////////////////////////////////////////////////

	//占썬끆�몌옙占썹빊遺욱뀱 - Canny Edge 占썩뫁��占싼딆뒠
	JNIEXPORT void JNICALL Java_com_secmem_spentest2_canvas_CanvasActivity_getEdge(JNIEnv* env, jobject thiz, jlong addrImage)
	{
		Mat& mat  = *((Mat*)addrImage);

		Mat destImage(mat.rows, mat.cols, CV_8U);

		destImage = mat.clone();

		mat.convertTo(mat, CV_8UC1);
		Canny(destImage, mat, 50, 100, 3);

		bitwise_not(mat, mat);
	}
}
