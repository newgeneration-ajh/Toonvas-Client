package com.secmem.spentest2.canvas;


import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;

import org.opencv.android.BaseLoaderCallback;
import org.opencv.android.LoaderCallbackInterface;
import org.opencv.android.OpenCVLoader;
import org.opencv.android.Utils;
import org.opencv.core.Mat;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.graphics.DashPathEffect;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.RectF;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.view.Display;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.RadioGroup;
import android.widget.RelativeLayout;
import android.widget.SeekBar;
import android.widget.TextView;
import android.widget.Toast;

import com.samsung.android.sdk.SsdkUnsupportedException;
import com.samsung.android.sdk.pen.Spen;
import com.samsung.android.sdk.pen.document.SpenNoteDoc;
import com.samsung.android.sdk.pen.document.SpenObjectBase;
import com.samsung.android.sdk.pen.document.SpenObjectContainer;
import com.samsung.android.sdk.pen.document.SpenObjectImage;
import com.samsung.android.sdk.pen.document.SpenObjectStroke;
import com.samsung.android.sdk.pen.document.SpenPageDoc;
import com.samsung.android.sdk.pen.document.SpenPageDoc.HistoryUpdateInfo;
import com.samsung.android.sdk.pen.document.SpenPageDoc.ObjectListener;
import com.samsung.android.sdk.pen.document.SpenPageDoc.ObjectSelectedListener;
import com.samsung.android.sdk.pen.engine.SpenContextMenuItemInfo;
import com.samsung.android.sdk.pen.engine.SpenControlList;
import com.samsung.android.sdk.pen.engine.SpenControlListener;
import com.samsung.android.sdk.pen.engine.SpenFlickListener;
import com.samsung.android.sdk.pen.engine.SpenSurfaceView;
import com.samsung.android.sdk.pen.engine.SpenTouchListener;
import com.samsung.android.sdk.pen.settingui.SpenSettingEraserLayout;
import com.samsung.android.sdk.pen.settingui.SpenSettingPenLayout;
import com.samsung.android.sdk.pen.settingui.SpenSettingSelectionLayout;
import com.secmem.canvasdrawing.DranwingManager;
import com.secmem.canvasdrawing.ObjectHandle;
import com.secmem.chat.ChatAdapter;
import com.secmem.chat.ChatData;
import com.secmem.layer.LayerAdapter;
import com.secmem.layer.LayerData;
import com.secmem.objecthandle.ObjectChanged;
import com.secmem.packet.BitmapRecvThread;
import com.secmem.packet.BitmapSendThread;
import com.secmem.packet.PacketData;
import com.secmem.packet.PacketType;
import com.secmem.packet.RecvThread;
import com.secmem.packet.SendManager;
import com.secmem.spentest2.R;


enum Method {
	INIT, ADDNOISE, NOISEBLUR, LIGHTING, ACCENTEDEDGES, CROSSHATCH, LAPLACIANSHARP, 
	MORELAPLACIANSHARP, UNSHARPENING, SHARPENEDGE, GRAPHICPENSKETCH, BASRELIEF,
	HALFTON, PHOTOCOPY, DIFFUSE, EMBOSS, FINDEDGES, SOLARIZE, COLORPENCIL,
	FILMGRAIN, PAINTDAUB, WATERCOLOR, GRAIN, MOSIACTILES, PATCHWORK,
	BLUR, MOREBLUR, GAUSSIANBLUR, MOTIONBLUR, GETEDGE
}

/*this class just used of test */
public class CanvasActivity extends Activity implements OnClickListener {
	/*	여기서 부터 영상처리 파트	*/
	private int 	addNoiseValue	= 0;
	private int		gaussianValue 	= 0;
	private int		grainValue 	= 0;
	private int		lightingValueX = 0, lightingValueY = 0, lightingValueRadian = 0;
	private int		mosaicValue = 0;
	private int 	motionValue = 0;
	private boolean isPen = false;
	private Context m_Context = this;
	
	private ObjectChanged m_ObjectChanged = null;
	
	private Bitmap 	openCVBitmap 	= null;	//여다가 비트맵 넣으면 됨!!!
	private Method	method 	= Method.INIT;
	
	private static final String    TAG = "OCVSample::Activity";
	
	private BaseLoaderCallback mOpenCVCallBack = new BaseLoaderCallback(this) {
		@Override
		public void onManagerConnected(int status) {
/*			if (LoaderCallbackInterface.SUCCESS != status) {
				return;
			}
			Log.i(TAG, "OpenCV loaded successfully");

			ArrayList<SpenObjectBase> tmpList = new ArrayList<SpenObjectBase>();
			
			for ( int i = 0 ; i < m_ObjectSel.size() ; i++ )
			{
				Mat mat = new Mat();
				
				SpenObjectBase tmpObject = m_ObjectSel.get(i);
				
				tmpList.add( tmpObject );
				
				openCVBitmap = m_SpenSurfaceView.drawObjectList(tmpList);
				
				Utils.bitmapToMat(openCVBitmap, mat);
				
				callNativeCV( method , mat );
				
				
				Utils.matToBitmap(mat, openCVBitmap);
				SpenObjectImage tmpImage = new SpenObjectImage();
				
				m_SpenPageDoc.removeObject(tmpObject);
				
				RectF rect = tmpObject.getRect();
				
				tmpImage.setImage(openCVBitmap);
			    tmpImage.setRect(rect, true);        
			    tmpImage.setExtraDataInt("Object ID", m_ObjectIdCnt);
			            
			    m_SpenPageDoc.appendObject(tmpImage);
			    
			            
			    openCVBitmap.recycle();
			    openCVBitmap = null;
			    
			    tmpList.remove(tmpObject);
			}*/
			
			m_SpenSurfaceView.update();
			
				
		}
	};
	
	/* S-Pen 기본	*/
	private Spen 					m_Spen 					= null;
	private SpenPageDoc			m_SpenPageDoc			= null;
	private SpenNoteDoc 			m_SpenNoteDoc			= null;
	private SpenSurfaceView		m_SpenSurfaceView 	= null;
	private RelativeLayout			m_RelativeLayout  		= null;
	private ImageButton			m_ObjecButton			= null;
	private ImageButton			m_EragerButton			= null;
	
	private ArrayList<SpenObjectBase> m_ObjectSel = null;
	
	
	private int						m_ToolType				= SpenSurfaceView.TOOL_SPEN;
	private int						m_Mode					= PEN_TYPE.MODE_PEN;
	
    private final int MODE_SELECTION = 0;
    private final int MODE_PEN = 1;
    private final int MODE_LAYER_CREATOR =  2;
    private final int MODE_ERASER = 3;
    
    private final int CONTEXT_MODE_DELETE_ID = 10;
    private final int CONTEXT_MODE_GROUP_ID = 20;
    private final int CONTEXT_MODE_UNGROUP_ID = 30;
	
	/*버튼*/
	private ImageButton m_AddLayerBtn = null;
	private ImageButton m_CutBtn = null;
	private ImageButton m_EraseBtn = null;
	private ImageButton m_PenBtn = null;
	private ImageButton m_RedoBtn = null;
	private ImageButton m_UndoBtn = null;
	private ImageButton m_AddPage = null;
	private Button m_sendBtn = null;
	private Button m_LayerCreator = null;
	
	
	private EditText m_etMsg = null;
	
	private PointF startP = null;
	private PointF endP = null;
	
	private Rect m_Rect = new Rect();
	
	
	/*채팅과 레이어 리스트 */
	private ListView lv_layer	= null;
	private LayerAdapter layer_adapter;
	private ArrayList<LayerData> layerList = new ArrayList<LayerData>();
	
	private ListView lv_chat	= null;
	private ChatAdapter chat_adapter;
	private ArrayList<ChatData> chatList = new ArrayList<ChatData>();
	
	/*셋팅뷰*/
	private SpenSettingEraserLayout m_SettingEraser = null;
	private SpenSettingSelectionLayout m_SettingSelction = null;
	private SpenSettingPenLayout m_SettingPan = null;
	
	private PageHandler m_PageHandler = null;
		
	private String m_roomNum = null;
	
	private String m_CahcePath = new String ("/sdcard/Toonvascache/inFile");
	
	/*pen info*/
	
	private SurfaceHolder m_Holder = null;
	
	private int m_LayerCnt = 0;

	private byte[] m_RoomNumArray = null;
	private BitmapSendThread m_BitmapSendThread = null;
	private BitmapRecvThread m_BitmapRecvThread = null;
	
	private FileInputStream m_FileInputStream = null;
	
	private Uri m_Uri = null;
	
	private int m_ObjectIdCnt = 0;
	/*
	private float oldS_x = 0.0f, oldS_y = 0.0f, oldE_x = 0.0f, oldE_y = 0.0f;*/
	
	private ObjectHandle m_ObjectHandle = null;
	
	private EditText m_PageText = null;
	
	private int m_PageCnt = 0;
	
	private File mFilePath;
	
	@Override
	protected void onCreate ( Bundle savedInstanceState ) {
		
		super.onCreate( savedInstanceState );
		setContentView( R.layout.activity_canvas );
		
		getActionBar().setTitle("");
		RecvThread.setHandler(m_Handler);
		Display display = getWindowManager().getDefaultDisplay();
		
		m_RelativeLayout = ( RelativeLayout ) findViewById( R.id.spenViewLayout );
		
		
		/*셋팅뷰*/
		m_SettingPan = new SpenSettingPenLayout(this , new String(), m_RelativeLayout);
		if ( m_SettingPan == null )
		{
			finish();
		}
		
		m_SettingSelction = new SpenSettingSelectionLayout( this , new String() , m_RelativeLayout );
		if ( m_SettingSelction == null )
		{
			finish();
		}
		
		m_SettingEraser = new SpenSettingEraserLayout( this , new String() , m_RelativeLayout );
		if ( m_SettingEraser == null )
		{
			finish();
		}
		
		/*레이어 버튼과 각종 버튼들*/
		
		m_CutBtn = (ImageButton) findViewById(R.id.imageButton_sel);
		m_CutBtn.setOnClickListener(this);
		
		m_EragerButton = (ImageButton) findViewById(R.id.imageButton_erase);
		m_EragerButton.setOnClickListener(this);
		
		m_PenBtn = (ImageButton) findViewById(R.id.imageButton_pen);
		m_PenBtn.setOnClickListener(this);
		
		m_RedoBtn = (ImageButton) findViewById(R.id.imageButton_redo);
		m_RedoBtn.setOnClickListener(this);
		
		m_UndoBtn = (ImageButton) findViewById(R.id.imageButton_undo);
		m_UndoBtn.setOnClickListener(this);
		m_AddPage = ( ImageButton ) findViewById( R.id.imageButton_page );
		m_AddPage.setOnClickListener( this );
		
		m_PageText = ( EditText ) findViewById( R.id.editBoxPageInfo );
		//m_PageText.setText
		
		startSpen();
		
		m_SpenSurfaceView = new SpenSurfaceView( this );

		display.getRectSize(m_Rect);

		
		try {
			m_SpenNoteDoc = new SpenNoteDoc(this , 2560, 1600);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		m_SpenPageDoc = m_SpenNoteDoc.appendPage();
		m_PageHandler = new PageHandler( m_SpenPageDoc );
		m_SpenPageDoc.setBackgroundColor(Color.WHITE );
		m_SpenPageDoc.clearHistory();
		
		m_SpenSurfaceView.setPageDoc(m_SpenPageDoc, true);
		
		m_RelativeLayout.addView( m_SpenSurfaceView );
		m_RelativeLayout.addView( m_SettingEraser );
		m_RelativeLayout.addView(m_SettingPan);
		m_RelativeLayout.addView(m_SettingSelction);
		
		m_SettingEraser.setCanvasView(m_SpenSurfaceView);
		m_SettingPan.setCanvasView(m_SpenSurfaceView);
		m_SettingSelction.setCanvasView(m_SpenSurfaceView);

//		m_SpenSurfaceView.setTouchListener(m_SpenTouchListener);
		m_SpenSurfaceView.setFlickListener(mFlickListener);
		
		m_Holder = m_SpenSurfaceView.getHolder();
		
		Intent i = getIntent();
	    m_roomNum = i.getExtras().getString("roomNum");
	    ByteBuffer tmpBuffer = ByteBuffer.allocate(4);
	    tmpBuffer.order(ByteOrder.LITTLE_ENDIAN);
	    tmpBuffer.putInt( Integer.parseInt( m_roomNum ) );
	    m_RoomNumArray = tmpBuffer.array();
	    
	    tmpBuffer = null;
	    m_SpenPageDoc.setObjectSelectedListener(m_ObjectSelcListener);
	    m_SpenPageDoc.setObjectListener(m_ObjectListener);
	    
	    
	    m_SpenSurfaceView.setControlListener(m_SpenControlListener);
	    
	    m_Mode = MODE_PEN;
	    
	    try {
			m_FileInputStream = new FileInputStream( m_CahcePath );
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	    
	    String filePath = Environment.getExternalStorageDirectory().getAbsolutePath() + "/Toonvas/";
        mFilePath = new File(filePath);
	}
	
	@Override
	protected void onStart() {
		super.onStart(); 
		// TODO Auto-generated method stub
		ByteBuffer tmpBuffer = ByteBuffer.allocate(4);
	    
	    tmpBuffer.order(ByteOrder.LITTLE_ENDIAN);
	    
	    tmpBuffer.putInt(Integer.parseInt(m_roomNum));
	    
	    tmpBuffer.flip();
	    
	    PacketData tmpData = new PacketData ( PacketType.REQ_CLIENTLIST , tmpBuffer.array() , 4);
	    SendManager.pushQueue(tmpData);
		
	}
	
	@Override
	protected void onResume() {
		// TODO Auto-generated method stub
		super.onResume();
		RecvThread.setHandler(m_Handler);
	}
	
	
	@Override	 
	public void onClick ( View v ) {
		int sel = v.getId();
		
		switch ( sel ) {
		case R.id.imageButton_sel :
			
			m_SpenSurfaceView.closeControl();

			// When Spen is in selection mode
            if (m_SpenSurfaceView.getToolTypeAction(m_ToolType) ==
                    SpenSurfaceView.ACTION_SELECTION) {
					// If SelectionSettingView is open, close it.
            	if (m_SettingSelction.isShown()) {
            		m_SettingSelction.setVisibility(View.GONE);
            		// If SelectionSettingView is not open, open it.
            	} else {
            		m_SettingSelction.setViewMode(SpenSettingSelectionLayout.VIEW_MODE_NORMAL);
            		m_SettingSelction.setVisibility(View.VISIBLE);
            	}
			// If Spen is not in selection mode, change it to selection mode.
            } else {
            	m_Mode = MODE_SELECTION;
            	selectButton(m_CutBtn);
            	m_SpenSurfaceView.setToolTypeAction(m_ToolType, SpenSurfaceView.ACTION_SELECTION);
            }
    
			break;
			
		case R.id.imageButton_pen :
			m_Mode = MODE_PEN;
			m_SpenSurfaceView.closeControl();

			// When Spen is in stroke (pen) mode
        if (m_SpenSurfaceView.getToolTypeAction(m_ToolType) == SpenSurfaceView.ACTION_STROKE) {
				// If PenSettingView is open, close it.
            if (m_SettingPan.isShown()) {
            	m_SettingPan.setVisibility(View.GONE);
				// If PenSettingView is not open, open it.
            } else {
            	m_SettingPan.setViewMode(SpenSettingPenLayout.VIEW_MODE_EXTENSION);
            	m_SettingPan.setVisibility(View.VISIBLE);
            }
			// If Spen is not in stroke (pen) mode, change it to stroke mode.
        } else {
            m_Mode = MODE_PEN;
            selectButton(m_PenBtn);
            m_SpenSurfaceView.setToolTypeAction(m_ToolType, SpenSurfaceView.ACTION_STROKE);
        }
			break;
		case R.id.imageButton_erase :
			m_Mode = MODE_ERASER;
			if (m_SpenSurfaceView.getToolTypeAction(m_ToolType) == SpenSurfaceView.ACTION_ERASER) {
				// If EraserSettingView is open, close it. 
				if (m_SettingEraser.isShown()) {
					m_SettingEraser.setVisibility(View.GONE);
					// If EraserSettingView is not open, open it.
				} else {
					m_SettingEraser
						.setViewMode(SpenSettingEraserLayout.VIEW_MODE_NORMAL);
					m_SettingEraser.setVisibility(View.VISIBLE);
				}
		// If Spen is not in eraser mode, change it to eraser mode.
			} else {
				//selectButton(m_EraseBtn);
				m_SpenSurfaceView.setToolTypeAction(m_ToolType,
						SpenSurfaceView.ACTION_ERASER);
			}
			break;
			
		case R.id.imageButton_undo :
			PacketData tmpPacket = new PacketData ( PacketType.REQ_UNDO , m_RoomNumArray , 4);
			SendManager.pushQueue( tmpPacket );
			tmpPacket = null;
			if ( m_SpenPageDoc.isUndoable() )
			{
				HistoryUpdateInfo[] userData = m_SpenPageDoc.undo();
				m_SpenSurfaceView.updateUndo(userData);
			}
			break;
		case R.id.imageButton_redo :
			tmpPacket = new PacketData ( PacketType.REQ_REDO , m_RoomNumArray , 4);
			SendManager.pushQueue( tmpPacket );
			tmpPacket = null;
			if ( m_SpenPageDoc.isRedoable() )
			{
				HistoryUpdateInfo[] userData = m_SpenPageDoc.redo();
				m_SpenSurfaceView.updateRedo(userData);
			}
			break;
			
		case R.id.imageButton_page :
			
			SendManager.pushQueue( PacketType.REQ_PAGE , Integer.parseInt( m_roomNum ));
			
			m_SpenPageDoc = m_SpenNoteDoc.appendPage();
			m_SpenPageDoc.setObjectListener(m_ObjectListener);
			m_SpenPageDoc.setObjectSelectedListener(m_ObjectSelcListener);
			m_PageHandler.insertPage( m_SpenPageDoc );
			m_SpenPageDoc.setBackgroundColor(Color.WHITE);
			m_SpenPageDoc.clearHistory();
			
			m_SpenSurfaceView.setPageDoc(m_SpenPageDoc, SpenSurfaceView.PAGE_TRANSITION_EFFECT_RIGHT, 
					SpenSurfaceView.PAGE_TRANSITION_EFFECT_TYPE_SHADOW, 0);
			
			break;
		default:
			break;
		}
	}
	

	
	private void selectButton(View v) {
		m_CutBtn.setSelected(false);
		m_PenBtn.setSelected(false);
		m_EragerButton.setSelected(false);
		
		v.setSelected(true);

		closeSettingView();
	}
	
	private void closeSettingView() {
			// Close all the setting views.
		m_SettingPan.setVisibility(SpenSurfaceView.GONE);
	    m_SettingEraser.setVisibility(SpenSurfaceView.GONE);
	    m_SettingSelction.setVisibility(SpenSurfaceView.GONE);
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		super.onActivityResult(requestCode, resultCode, data);
		switch(requestCode) {
		case 100:
		if(resultCode == 0) break;
			Uri uri = data.getData();
			LayerData layer = new LayerData(  m_LayerCnt++ );
			layer_adapter.insertItem(layer);
            FileInputStream inputStream = null;
            m_Uri = uri;
            
			try {
				inputStream = new FileInputStream( getPathFromUri( uri ) );
				SendManager.pushQueue(PacketType.REQ_STRAT_BITMAP, m_RoomNumArray , ++m_ObjectIdCnt );
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
            Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
            SpenObjectImage tmpImage = new SpenObjectImage();
            
            tmpImage.setExtraDataInt("Object ID", m_ObjectIdCnt);
            
            float imgWidth = bitmap.getWidth() / 2;
            float imgHeight = bitmap.getHeight() / 2;
            
            RectF rect = getRealPoint(500, 500, imgWidth, imgHeight);
            
            tmpImage.setImage(bitmap);
            tmpImage.setRect(rect, true);
            m_SpenPageDoc.appendObject(tmpImage);
            m_SpenSurfaceView.update();
            
            bitmap.recycle();
			break;
		}
	}

	private void startSpen () {
		@SuppressWarnings("unused")
		boolean isSpenFeatureEnable = false;
		m_Spen = new Spen ();
		try {
			m_Spen.initialize( this );	
			isSpenFeatureEnable = m_Spen.isFeatureEnabled( Spen.DEVICE_PEN );
		} catch ( SsdkUnsupportedException e1 ) {
			if ( ( SsdkUnsupportedException.VENDOR_NOT_SUPPORTED ) == 0 ) {
				return;
			}
		} catch ( Exception e1) {
			// TODO: handle exception
			e1.printStackTrace();
			finish();
		}
	}

	final SpenTouchListener m_SpenTouchListener	= new SpenTouchListener( ) {
		
		@Override
		public boolean onTouch(View view, MotionEvent event) {
		if ( m_Mode == MODE_LAYER_CREATOR )
		{
			m_SpenSurfaceView.cancelStroke();
			DashPathEffect tmpEffect = new DashPathEffect(new float[]{5,5}, 1);
			
			if ( event.getToolType(0) == m_ToolType && event.getAction() == MotionEvent.ACTION_DOWN )
			{
				Log.d("Point", "down");
				startP = new PointF(event.getX(), event.getY() );
				return true;
			}
			else if ( event.getToolType(0) == m_ToolType && event.getAction() == MotionEvent.ACTION_UP )
			{
				Log.d("Point", "Up");
				endP = new PointF ( event.getX() , event.getY() );
				return true;
			}
			else if ( event.getToolType(0) == m_ToolType && event.getAction() == MotionEvent.ACTION_MOVE )
			{

				
				return true;
			}
		}
		return true;
		}
	};
	
	@SuppressLint("HandlerLeak")
	final Handler	m_Handler	= new Handler( ) {
		@Override
		public void handleMessage ( Message msg )
		{
			if ( msg.what == PacketType.RET_PEN_UP)
			{
				
				SpenObjectStroke tmpData = ( SpenObjectStroke ) msg.obj;
				
				tmpData.setMovable(false);
				tmpData.setSelectable(false);
				
				int tmpInt = tmpData.getExtraDataInt("otherData");
			
				m_ObjectHandle.inSertObject( tmpInt , tmpData);
				
				SpenPageDoc tmpPageDoc = m_SpenNoteDoc.getPage( tmpData.getExtraDataInt("Page"));
				
				tmpPageDoc.appendObject(tmpData);
				
				m_SpenSurfaceView.update();
				
				
			}
			else if ( msg.what == PacketType.RET_ROOMCLIENTLIST )
			{
				byte[] tmpByte = DranwingManager.setBundle(msg.getData());
				ByteBuffer tmpBuffer = ByteBuffer.wrap(tmpByte);
				tmpBuffer.order(ByteOrder.LITTLE_ENDIAN);
				
				int keyCnt = tmpByte.length/4;
				
				int key[] = new int[ keyCnt ];
			
				for ( int i = 0 ; i < keyCnt ; i++ )
				{
					key[i] = 0;
					key[1] = 100;
				}
				m_ObjectHandle = new ObjectHandle(key);
				
			}
			
			else if ( msg.what == PacketType.RET_UNDO )
			{
				if ( m_SpenPageDoc.isUndoable() )
				{
					HistoryUpdateInfo[] userData = m_SpenPageDoc.undo();
					m_SpenSurfaceView.updateUndo(userData);
				}
			}
			else if ( msg.what == PacketType.RET_REDO )
			{
				if ( m_SpenPageDoc.isRedoable() )
				{
					HistoryUpdateInfo[] userData = m_SpenPageDoc.redo();
					m_SpenSurfaceView.updateRedo(userData);
				}
			}
			else if ( msg.what == PacketType.RET_START_BITMAP )
			{
				if ( m_BitmapSendThread == null )
				{
					m_BitmapSendThread = new BitmapSendThread(getPathFromUri( m_Uri ) , Integer.parseInt(m_roomNum) , m_ObjectIdCnt);
				}
				else
				{
					m_BitmapSendThread.setBitmapPath( getPathFromUri( m_Uri ) , m_ObjectIdCnt );
				}
				
			}
			
			else if ( msg.what == PacketType.RET_OTHER_START_BITMAP )
			{
				byte[] tmpBytes = DranwingManager.setBundle(msg.getData());
				
				ByteBuffer buffer = ByteBuffer.allocate(tmpBytes.length);
				
				buffer.put( tmpBytes );
				
				int otherSocket = buffer.getInt(0);
				
				int otherObjectId = buffer.getInt(4);
				
				if ( m_BitmapRecvThread == null )
				{
					m_BitmapRecvThread = new BitmapRecvThread( otherSocket , otherObjectId );
				}
				else
				{
					m_BitmapRecvThread.setFilePath( otherSocket , otherObjectId );
				}
				
			}
			
			else if ( msg.what == PacketType.RET_BITMAP_DATA )
			{
				byte[] tmpBytes = DranwingManager.setBundle(msg.getData());
				
				ByteBuffer buffer = ByteBuffer.allocate(tmpBytes.length);
				
				buffer.put( tmpBytes );
				
				int otherSocket = buffer.getInt(0);
				
				int otherObjectId = buffer.getInt(4);
				
				buffer.clear();
				
				buffer.put(tmpBytes, 8, tmpBytes.length - 8);
				
				buffer.flip();
				
				m_BitmapRecvThread.setFileBytes( buffer.array() , otherSocket , otherObjectId );
			}
			else if ( msg.what == PacketType.RET_END_BITMAP )
			{	
				byte[] tmpBytes = DranwingManager.setBundle(msg.getData());
				ByteBuffer tmpBuffer = ByteBuffer.wrap(tmpBytes);
				tmpBuffer.order(ByteOrder.LITTLE_ENDIAN);
				
				int otherSocket = tmpBuffer.getInt();
				int otherObjectId = tmpBuffer.getInt(4);
				
				m_BitmapRecvThread.closeFile( otherSocket , otherObjectId );
				try {
					m_FileInputStream = new FileInputStream( m_CahcePath+Integer.toString(otherSocket)+
							Integer.toString(otherObjectId)+".bmp" );
				} catch (FileNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				Bitmap bitmap = BitmapFactory.decodeStream(m_FileInputStream);
	            
	            if ( bitmap != null )
	            {
	            	SpenObjectImage tmpImage = new SpenObjectImage();
	            	
	            	tmpImage.setExtraDataInt("Object ID", tmpBuffer.getInt(4));
	            	
	            	m_ObjectHandle.inSertObject(tmpBuffer.getInt() , tmpImage );
	            	
		            float imgWidth = bitmap.getWidth() / 2;
		            float imgHeight = bitmap.getHeight() / 2;
		            
		            RectF rect = getRealPoint(500, 500, imgWidth, imgHeight);
		            
		            tmpImage.setImage(bitmap);
		            tmpImage.setRect(rect, true);
		            m_SpenPageDoc.appendObject(tmpImage);
		            m_SpenSurfaceView.update();
		            
		            bitmap.recycle();
	            }
	            else
	            {
	            	Log.d("bitmap", "this it not image file");
	            }
			}
			else if ( msg.what == PacketType.RET_OBJECT_CHANGE )
			{
				byte[] tmpByte = DranwingManager.setBundle(msg.getData());
				int tmpLength = tmpByte.length;
				ByteBuffer tmpBuffer = ByteBuffer.allocate( tmpLength );
				tmpBuffer.order(ByteOrder.LITTLE_ENDIAN);
				
				tmpBuffer.put( tmpByte , 0 , tmpLength );
				
				tmpBuffer.flip();
				
				int tmpMasterId = tmpBuffer.getInt();
				tmpLength = tmpBuffer.getInt( 4 );
				
				for ( int i = 0 ; i < tmpLength ; i++ )
				{
					int tmpId = tmpBuffer.getInt( ( i * 20 ) + 4 + 4 );
					RectF tmpRect = new RectF();
					tmpRect.top = tmpBuffer.getFloat( ( i * 20 ) + 4 + 4 + 4 );
					tmpRect.bottom = tmpBuffer.getFloat( ( i * 20 ) + 4 + 4 + 4 + 4 );
					tmpRect.left = tmpBuffer.getFloat( ( i * 20 ) + 4 + 4 + 4 + 4 + 4 );
					tmpRect.right = tmpBuffer.getFloat( ( i * 20 ) + 4 + 4 + 4 + 4 + 4 + 4 ); 
					SpenObjectBase tmpObject = m_ObjectHandle.getObject(0, tmpId);
					
					SpenPageDoc tmpPage = m_SpenNoteDoc.getPage( tmpObject.getExtraDataInt("Page"));
					
					tmpObject.setRect(tmpRect, false);
					
					tmpPage.removeObject( tmpObject );
					tmpPage.appendObject( tmpObject );
				}
				
				m_SpenSurfaceView.update();
			}
			else if ( msg.what == PacketType.RET_PAGE )
			{
				SpenPageDoc tmpPageDoc = m_SpenNoteDoc.appendPage();
				tmpPageDoc.setBackgroundColor(Color.WHITE);
				
				tmpPageDoc.setObjectListener(m_ObjectListener);
				tmpPageDoc.setObjectSelectedListener(m_ObjectSelcListener);
				
				m_SpenSurfaceView.setPageDoc(tmpPageDoc, false);
			}
			else if ( msg.what == PacketType.RET_IMAGE_PROCESSING )
			{
				
			}
			
			else if ( msg.what == PacketType.RET_OBJECT_START )
			{
				
			}
			
			else if ( msg.what == PacketType.RET_OBJECT_DATA )
			{
				
			}
			else if ( msg.what == PacketType.RET_OBJECT_END )
			{
				SpenObjectStroke tmpData = ( SpenObjectStroke ) msg.obj;
				
				tmpData.setMovable(false);
				tmpData.setSelectable(false);
				
				int tmpInt = tmpData.getExtraDataInt("otherData");
			
				m_ObjectHandle.inSertObject( tmpInt , tmpData);
				
				SpenPageDoc tmpPageDoc = m_SpenNoteDoc.getPage( tmpData.getExtraDataInt("Page"));
				
				tmpPageDoc.appendObject(tmpData);
				
				m_SpenSurfaceView.update();
			}
			
			else
			{
				Log.d("Packet Unknown" , Integer.toString(msg.what) );
			}
			
		}
		
	};
	
	private final ObjectListener m_ObjectListener = new ObjectListener() {
		
		@Override
		public void onObjectAdded(SpenPageDoc arg0, ArrayList<SpenObjectBase> arg1,
				int arg2) {
			// TODO Auto-generated method stub	
			SpenObjectBase tmpObject = arg1.get(0);
			if ( tmpObject.hasExtraDataInt("otherData") == false )
			{
				m_ObjectIdCnt++;
				tmpObject.setExtraDataInt("Object ID", m_ObjectIdCnt);
				tmpObject.setExtraDataInt( "Page" , m_SpenNoteDoc.getPageIndexById(m_SpenPageDoc.getId()));
				
				if ( tmpObject.getType() == SpenObjectBase.TYPE_STROKE )
				{
					SpenObjectStroke tmpStroke = ( SpenObjectStroke ) tmpObject;
					if ( m_Mode == MODE_PEN )
					{
						SendManager.pushQueue( tmpStroke , Integer.parseInt( m_roomNum ) );
					}
					else if ( m_Mode == MODE_ERASER )
					{
						tmpStroke.setSelectable(false);
						SendManager.pushQueue( tmpStroke , Integer.parseInt( m_roomNum ) , SpenObjectStroke.TOOL_TYPE_ERASER );
					}
				}
				
			}
		}

		@Override
		public void onObjectChanged(SpenPageDoc arg0, SpenObjectBase arg1, int arg2) 
		{
				// TODO Auto-generated method stub
			if ( arg1.hasExtraDataInt("otherData") == false)
			{
				if ( m_ObjectChanged == null )
				{
					m_ObjectChanged = new ObjectChanged(m_ObjectSel, Integer.parseInt(m_roomNum));
				}
				else
				{
					m_ObjectChanged.chnagedObject(arg1);
					if ( m_ObjectChanged.getResult() == true )
					{
						m_ObjectChanged = null;
					}
				}
			}
		}
		
		@Override
		public void onObjectRemoved(SpenPageDoc arg0,
				ArrayList<SpenObjectBase> arg1, int arg2) {
			// TODO Auto-generated method stub
			Log.d("Object Removed" , "_-_" );
		}
	};
	
	private final ObjectSelectedListener m_ObjectSelcListener = new ObjectSelectedListener() {
		
		@Override
		public void onObjectSelected(SpenPageDoc arg0,
				ArrayList<SpenObjectBase> arg1, boolean arg2) {
			Log.d("Object Sel" , "_D_");
			m_ObjectSel = arg1;
			// TODO Auto-generated method stub
			
		}
	};
	
	
	@Override
	public void onBackPressed() {
		// TODO Auto-generated method stub
		
		super.onBackPressed();
	}
	
	private final SpenControlListener m_SpenControlListener = new SpenControlListener() {
		
		@Override
		public void onRotationChanged(float arg0, SpenObjectBase arg1) {
			// TODO Auto-generated method stub
			
		}
		
		@Override
		public void onRectChanged(RectF arg0, SpenObjectBase arg1) {
			// TODO Auto-generated method stub
			Log.d("RectChanged","Oh");
		}
		
		@Override
		public void onObjectChanged(ArrayList<SpenObjectBase> arg0) {
			// TODO Auto-generated method stub
			
		}
		
		@Override
		public boolean onMenuSelected(ArrayList<SpenObjectBase> arg0, int arg1) {
			// TODO Auto-generated method stub
			SpenObjectContainer tmpContainer;
			switch ( arg1 )
			{
			case CONTEXT_MODE_DELETE_ID :
				for ( SpenObjectBase obj : arg0 )
				{
					m_SpenPageDoc.removeObject(obj);
				}
				m_SpenSurfaceView.closeControl();
				m_SpenSurfaceView.update();
				break;
			case CONTEXT_MODE_GROUP_ID :
				tmpContainer = m_SpenPageDoc.groupObject(arg0, false);
				m_SpenSurfaceView.closeControl();
				m_SpenPageDoc.selectObject(tmpContainer);
				m_SpenSurfaceView.update();
				break;
			case CONTEXT_MODE_UNGROUP_ID :
				ArrayList < SpenObjectBase > tmpObjectList = new ArrayList < SpenObjectBase >();
				for ( SpenObjectBase selObj : arg0 )
				{
					if ( selObj.getType() == SpenObjectBase.TYPE_CONTAINER )
					{
						tmpContainer = ( SpenObjectContainer ) selObj;
						for ( SpenObjectBase obj : tmpContainer.getObjectList() )
						{
							tmpObjectList.add(obj);
						}
						m_SpenPageDoc.ungroupObject( ( SpenObjectContainer ) selObj, false);
					}
				}
				
				m_SpenSurfaceView.closeControl();
				m_SpenPageDoc.selectObject(tmpObjectList);
				m_SpenSurfaceView.update();
				break;
			}
			return false;
		}
		
		@Override
		public boolean onCreated(ArrayList<SpenObjectBase> arg0,
				ArrayList<Rect> arg1, ArrayList<SpenContextMenuItemInfo> arg2,
				ArrayList<Integer> arg3, int arg4, PointF arg5) {
			// TODO Auto-generated method stub
			
			//arg2.add ( new SpenContextMenuItemInfo(CONTEXT_MODE_DELETE_ID, "Delete", true));
			
			if ( arg0.size() > 1 )
			{
				arg2.add( new SpenContextMenuItemInfo(CONTEXT_MODE_GROUP_ID, "Group", true));
			}
			
			for ( SpenObjectBase obj : arg0 )
			{
				if ( obj.getType() == SpenObjectBase.TYPE_CONTAINER )
				{
					arg2.add( new SpenContextMenuItemInfo(CONTEXT_MODE_UNGROUP_ID, "Ungroup", true));
				}
			}
			
			if ( arg0.size() == 1 )
			{
				return true;
			}
			
			SpenControlList controlList = new SpenControlList( m_Context , m_SpenPageDoc );
			controlList.setObject(arg0);
			controlList.setGroup(false);
			m_SpenSurfaceView.setControl(controlList);
			controlList.setContextMenu(arg2);
			
			return false;
		}
		
		@Override
		public boolean onClosed(ArrayList<SpenObjectBase> arg0) {
			// TODO Auto-generated method stub
			return false;
		}
	};

	private final SpenFlickListener mFlickListener = new SpenFlickListener() {

        @Override
        public boolean onFlick(int direction) {
            int pageIndex = m_SpenNoteDoc.getPageIndexById(m_SpenPageDoc.getId());
            int pageCount = m_SpenNoteDoc.getPageCount();
            if (pageCount > 1) {
                // Flick left and turn to the previous page.
                if (direction == DIRECTION_LEFT) {
                    m_SpenPageDoc = m_SpenNoteDoc.getPage((pageIndex + pageCount - 1) % pageCount);
                    m_SpenSurfaceView.setPageDoc(m_SpenPageDoc, SpenSurfaceView.PAGE_TRANSITION_EFFECT_LEFT,
                            SpenSurfaceView.PAGE_TRANSITION_EFFECT_TYPE_SHADOW, 0);

                    // Flick right and turn to the next page.
                } else if (direction == DIRECTION_RIGHT) {
                    m_SpenPageDoc = m_SpenNoteDoc.getPage((pageIndex + 1) % pageCount);
                    m_SpenSurfaceView.setPageDoc(m_SpenPageDoc, SpenSurfaceView.PAGE_TRANSITION_EFFECT_RIGHT,
                            SpenSurfaceView.PAGE_TRANSITION_EFFECT_TYPE_SHADOW, 0);
                }
                /*m_TxtView = (TextView) findViewById(R.id.spen_page);
                mTxtView.setText("Page" + mSpenNoteDoc.getPageIndexById(mSpenPageDoc.getId()));*/
                return true;
            }
            return false;
        }
    };
    

	
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		getMenuInflater().inflate(R.menu.menu_toonvas, menu);
		return super.onCreateOptionsMenu(menu);
	}
	

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		//openCVBitmap = getBitmap();
		switch(item.getItemId())
		{
			/*case R.id.accented_edges:
				method = Method.ACCENTEDEDGES;
				break;
			case R.id.add_noise:	
				addNoiseDialog();
				return super.onOptionsItemSelected(item);
			case R.id.bas_relief:
				method = Method.BASRELIEF;
				break;
			case R.id.blur_b:
				method = Method.BLUR;
				break;
			case R.id.color_pencil:
				method = Method.COLORPENCIL;
				break;
			case R.id.crosshatch:
				method = Method.CROSSHATCH;
				break;
			case R.id.diffuse:
				method = Method.DIFFUSE;
				break;
			case R.id.emboss:
				method = Method.EMBOSS;
				break;
			case R.id.film_grain:
				method = Method.FILMGRAIN;
				break;
			case R.id.find_edges:
				method = Method.FINDEDGES;
				break;
			case R.id.gaussian_blur:
				gaussianBlurDialog();
				return super.onOptionsItemSelected(item);
			case R.id.get_edge_e:
				method = Method.GETEDGE;
				break;
			case R.id.grain:
				grainNoiseDialog();
				return super.onOptionsItemSelected(item);
			case R.id.graphic_pen_sketch:
				method = Method.GRAPHICPENSKETCH;
				break;
			case R.id.half_ton:
				method = Method.HALFTON;
				break;
			case R.id.laplaciansharp:
				method = Method.LAPLACIANSHARP;
				break;
			case R.id.light:
				lightingDialog();
				return super.onOptionsItemSelected(item);
			case R.id.more_blur:
				method = Method.MOREBLUR;
				break;
			case R.id.more_laplaciansharp:
				method = Method.MORELAPLACIANSHARP;
				break;
			case R.id.mosaic_tiles:
				mosaicTilesDialog();
				return super.onOptionsItemSelected(item);
			case R.id.motion_blur:
				motionBlurDialog();
				return super.onOptionsItemSelected(item);
			case R.id.noise_blur:
				method = Method.NOISEBLUR;
				break;
			case R.id.paint_daub:
				method = Method.PAINTDAUB;
				break;
			case R.id.patch_work:
				method = Method.PATCHWORK;
				break;
			case R.id.photo_copy:
				method = Method.PHOTOCOPY;
				break;
			case R.id.sharpen_edge:
				method = Method.SHARPENEDGE;
				break;
			case R.id.solarize:
				method = Method.SOLARIZE;
				break;
			case R.id.unsharpening:
				method = Method.UNSHARPENING;
				break;
			case R.id.watercolor:
				method = Method.WATERCOLOR;
				break;*/
			case R.id.save_to_drive:
				saveNoteFile(false);
				break;
		/*	case R.id.load_from_drive:
				m_SpenSurfaceView.closeControl();
	
	            closeSettingView();
	            
				//loadNoteFile();
	
				break;*/			
			default:
				return super.onOptionsItemSelected(item);
		}
		
		ProgressDlg dialog = new ProgressDlg(CanvasActivity.this);
		dialog.execute();
		
		return super.onOptionsItemSelected(item);
	}
	
	private Bitmap getBitmap ( ){
		return m_SpenSurfaceView.drawObjectList(m_SpenPageDoc.getObjectList());
	}
	private RectF getRealPoint(float x, float y, float width, float height) {
        float panX = m_SpenSurfaceView.getPan().x;
        float panY = m_SpenSurfaceView.getPan().y;
        float zoom = m_SpenSurfaceView.getZoomRatio();
        width *= zoom;
        height *= zoom;
        RectF realRect = new RectF();
        realRect.set((x - width / 2) / zoom + panX, (y - height / 2) / zoom + panY, (x + width / 2) / zoom + panX,
                (y + height / 2) / zoom + panY);
        return realRect;
    }

	public String getPathFromUri(Uri uri){
		Cursor cursor = getContentResolver().query(uri, null, null, null, null );
		cursor.moveToNext(); 
		String path = cursor.getString( cursor.getColumnIndex( "_data" ) );
		cursor.close();

		return path;
	}

	
	
	public void addNoiseDialog(){
		final AlertDialog.Builder popDialog = new AlertDialog.Builder(this);
		final LinearLayout ViewLayout = (LinearLayout)View.inflate(CanvasActivity.this,R.layout.add_noise, null);
		final TextView addNoiseText = (TextView)ViewLayout.findViewById(R.id.addNoise_seekbar_value);
		
		SeekBar seek = (SeekBar)ViewLayout.findViewById(R.id.addNoise_seekbar);
		seek.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) {
				// TODO Auto-generated method stub
				addNoiseText.setText(progress+"");
				addNoiseValue = progress;
			}
		});
		
		popDialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				method = Method.ADDNOISE;
				
				ProgressDlg progress = new ProgressDlg(CanvasActivity.this);
				progress.execute();
				dialog.dismiss();
			}
		});
		
		popDialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				dialog.dismiss();
			}
		});
		
		popDialog.setTitle("잡음 추가 수치 설정");
		popDialog.setView(ViewLayout);
		
		popDialog.create();
		popDialog.show();
	}
	
	public void gaussianBlurDialog(){
		final AlertDialog.Builder popDialog = new AlertDialog.Builder(this);
		final LinearLayout ViewLayout = (LinearLayout)View.inflate(CanvasActivity.this,R.layout.gaussian_blur, null);
		final TextView gaussianBlurText = (TextView)ViewLayout.findViewById(R.id.gaussian_seekbar_value);
		
		SeekBar seek = (SeekBar)ViewLayout.findViewById(R.id.gaussian_seekbar);
		seek.setThumbOffset(2);
		seek.setThumbOffset(-2);
		seek.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { 
				// TODO Auto-generated method stub
				gaussianBlurText.setText(progress+"");
				gaussianValue = progress;
			}
		});
		
		popDialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				method = Method.GAUSSIANBLUR;
				
				ProgressDlg progress = new ProgressDlg(CanvasActivity.this);
				progress.execute();
				dialog.dismiss();
			}
		});
		
		popDialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				dialog.dismiss();
			}
		});
		
		popDialog.setTitle("가우시안 블러 수치 설정");
		popDialog.setView(ViewLayout);
		
		popDialog.create();
		popDialog.show();
	}
	
	public void grainNoiseDialog(){
		final AlertDialog.Builder popDialog = new AlertDialog.Builder(this);
		final LinearLayout ViewLayout = (LinearLayout)View.inflate(CanvasActivity.this,R.layout.grain_noise, null);
		final TextView grainNoiseText = (TextView)ViewLayout.findViewById(R.id.grainNoise_seekbar_value);
		
		popDialog.setTitle("그레인 효과 수치 설정");
		popDialog.setView(ViewLayout);
		
		
		SeekBar seek = (SeekBar)ViewLayout.findViewById(R.id.grainNoise_seekbar);
		seek.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub	
			}
			
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) {
				// TODO Auto-generated method stub
				grainNoiseText.setText(progress+"");
				grainValue = progress;
			}
		});
		
		popDialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				method = Method.GRAIN;
				
				ProgressDlg progress = new ProgressDlg(CanvasActivity.this);
				progress.execute();
				dialog.dismiss();
			}
		});
		
		popDialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				dialog.dismiss();
			}
		});
		
		popDialog.create();
		popDialog.show();
	}
	
	public void lightingDialog(){
		final AlertDialog.Builder popDialog = new AlertDialog.Builder(this);
		final LinearLayout ViewLayout = (LinearLayout)View.inflate(CanvasActivity.this,R.layout.lighting, null);
		final TextView lightingTextX = (TextView)ViewLayout.findViewById(R.id.xPos_seekbar_value);
		final TextView lightingTextY = (TextView)ViewLayout.findViewById(R.id.yPos_seekbar_value);
		final TextView lightingTextR = (TextView)ViewLayout.findViewById(R.id.radian_seekbar_value);
			
		SeekBar seekX = (SeekBar)ViewLayout.findViewById(R.id.xPos_seekbar);
		seekX.setMax(openCVBitmap.getWidth());
		seekX.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) {
				// TODO Auto-generated method stub
				lightingTextX.setText(progress+"");
				lightingValueX = progress;
			}
		});
		
		SeekBar seekY = (SeekBar)ViewLayout.findViewById(R.id.yPos_seekbar);
		seekY.setMax(openCVBitmap.getHeight());
		seekY.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) {
				// TODO Auto-generated method stub
				lightingTextY.setText(progress+"");
				lightingValueY = progress;
			}
		});
		
		SeekBar seekR = (SeekBar)ViewLayout.findViewById(R.id.radian_seekbar);
		seekR.setMax(Math.min(openCVBitmap.getWidth(),openCVBitmap.getHeight()));
		seekR.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) {
				// TODO Auto-generated method stub
				lightingTextR.setText(progress+"");
				lightingValueRadian = progress;
			}
		});
		
		popDialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				method = Method.LIGHTING;
				
				ProgressDlg progress = new ProgressDlg(CanvasActivity.this);
				progress.execute();
				dialog.dismiss();
			}
		});
		
		popDialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				dialog.dismiss();
			}
		});
		
		popDialog.setTitle("조명 효과 수치 설정");
		popDialog.setView(ViewLayout);
		
		popDialog.create();
		popDialog.show();
	}
	 
	public void mosaicTilesDialog(){
		final AlertDialog.Builder popDialog = new AlertDialog.Builder(this);
		final LinearLayout ViewLayout = (LinearLayout)View.inflate(CanvasActivity.this,R.layout.mosaic_tiles, null);
		final TextView mosaicTilesText = (TextView)ViewLayout.findViewById(R.id.mosaic_tiles_seekbar_value);
		
		SeekBar seek = (SeekBar)ViewLayout.findViewById(R.id.mosaic_tiles_seekbar);
		
		seek.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub
			}
			
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
				// TODO Auto-generated method stub	
			}
			
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) {
				// TODO Auto-generated method stub
				mosaicTilesText.setText(progress+"");
				mosaicValue = progress;
			}
		});
		
		popDialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				method = Method.MOSIACTILES;
				
				ProgressDlg progress = new ProgressDlg(CanvasActivity.this);
				progress.execute();
				dialog.dismiss();
			}
		});
		
		popDialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				dialog.dismiss();
			}
		});
		
		popDialog.setTitle("모자이크 타일 수치 설정");
		popDialog.setView(ViewLayout);
	
		popDialog.create();
		popDialog.show();
	}
	
	public void motionBlurDialog(){
		final AlertDialog.Builder popDialog = new AlertDialog.Builder(this);
		final LayoutInflater inflater = (LayoutInflater)this.getSystemService(LAYOUT_INFLATER_SERVICE);
		final View ViewLayout = inflater.inflate(R.layout.motion_blur, (ViewGroup)findViewById(R.id.motion_blur_dialog));
		
		popDialog.setTitle("모션 블러 방향 설정");
		popDialog.setView(ViewLayout);
		
		RadioGroup radioGroup = (RadioGroup)ViewLayout.findViewById(R.id.motion_radio);
		radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {
			
			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				// TODO Auto-generated method stub
				switch(checkedId){
					case R.id.doHorizontal:
						motionValue = 0;
						break;
					case R.id.doVertical:
						motionValue = 1;
						break;
				}
			}
		});
		
		popDialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				method = Method.MOTIONBLUR;
				
				ProgressDlg progress = new ProgressDlg(CanvasActivity.this);
				progress.execute();
				dialog.dismiss();
			}
		});
		
		popDialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				dialog.dismiss();
			}
		});
		
		popDialog.create();
		popDialog.show();
	}
	
	private class ProgressDlg extends AsyncTask<Void, Void, Void>{
		private ProgressDialog dialog;
		private Context mContext;
		
		ProgressDlg(Context context){
			mContext = context;
		}
		
		protected void onPreExecute() {
			dialog = new ProgressDialog(mContext);
			dialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
			dialog.setCancelable(false);
			dialog.setIndeterminate(true);
			dialog.show();
			
			super.onPreExecute();
		}
		
		@Override
		protected Void doInBackground(Void... param) {
			// TODO Auto-generated method stub
			OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_2_4_7, CanvasActivity.this, mOpenCVCallBack);
			return null;
		}
		
		protected void onProgressUpdate(Void... progress) {
			
		}
		
		protected void onPostExecute(Void result) {
			dialog.dismiss();
			Toast.makeText(mContext, "Complete", Toast.LENGTH_SHORT).show();
		}
	}
	private boolean saveNoteFile(final boolean isClose) {
        // Prompt Save File dialog to get the file name
        // and get its save format option (note file or image).
        LayoutInflater inflater = (LayoutInflater) m_Context.getSystemService(LAYOUT_INFLATER_SERVICE);
        final View layout = inflater.inflate(R.layout.save_file_dialog, (ViewGroup) findViewById(R.id.layout_root));

        AlertDialog.Builder builderSave = new AlertDialog.Builder(m_Context);
        builderSave.setTitle("Enter file name");
        builderSave.setView(layout);

        final EditText inputPath = (EditText) layout.findViewById(R.id.input_path);
        inputPath.setText("Note");

        builderSave.setPositiveButton("OK", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {

                final RadioGroup selectFileExt = (RadioGroup) layout.findViewById(R.id.radioGroup);

                // Set save directory for the file.
                String saveFilePath = mFilePath.getPath() + '/';
                String fileName = inputPath.getText().toString();
                if (!fileName.equals("")) {
                    saveFilePath += fileName;
                    switch (selectFileExt.getCheckedRadioButtonId()) {
                    // Save it as a note file.
                    case R.id.radioNote:
                        saveFilePath += ".spd";
                        saveNoteFile(saveFilePath);

                        break;

                    // Save it as an image.
                    case R.id.radioImage:
                        saveFilePath += ".png";
                        captureSpenView(saveFilePath);

                        break;
                    }
                    if (isClose) {
                        finish();
                    }
                } else {
                    Toast.makeText(m_Context, "Invalid filename !!!", Toast.LENGTH_LONG).show();
                }
            }
        });
        builderSave.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                if (isClose) {
                    finish();
                }
            }
        });

        AlertDialog dlgSave = builderSave.create();
        dlgSave.show();

        return true;
    }
	
	private boolean saveNoteFile(String strFileName) {
        try {
            // Save NoteDoc
            m_SpenNoteDoc.save(strFileName);
            Toast.makeText(m_Context, "Save success to " + strFileName, Toast.LENGTH_SHORT).show();
        } catch (IOException e) {
            Toast.makeText(m_Context, "Cannot save NoteDoc file.", Toast.LENGTH_SHORT).show();
            e.printStackTrace();
            return false;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }
	
	 private void captureSpenView(String strFileName) {

	        // Capture the view
	        Bitmap imgBitmap = m_SpenSurfaceView.captureCurrentView(true);
	        if (imgBitmap == null) {
	            Toast.makeText(m_Context, "Capture failed." + strFileName, Toast.LENGTH_SHORT).show();
	            return;
	        }

	        OutputStream out = null;
	        try {
	            // Create FileOutputStream and save the captured image.
	            out = new FileOutputStream(strFileName);
	            imgBitmap.compress(CompressFormat.PNG, 100, out);
	            // Save the note information.
	            m_SpenNoteDoc.save(out);
	            out.close();
	            Toast.makeText(m_Context, "Captured images were stored in the file" + strFileName, Toast.LENGTH_SHORT)
	                    .show();
	        } catch (IOException e) {
	            File tmpFile = new File(strFileName);
	            if (tmpFile.exists()) {
	                tmpFile.delete();
	            }
	            Toast.makeText(m_Context, "Failed to save the file.", Toast.LENGTH_SHORT).show();
	            e.printStackTrace();
	        } catch (Exception e) {
	            File tmpFile = new File(strFileName);
	            if (tmpFile.exists()) {
	                tmpFile.delete();
	            }
	            Toast.makeText(m_Context, "Failed to save the file.", Toast.LENGTH_SHORT).show();
	            e.printStackTrace();
	        }
	        imgBitmap.recycle();
	    }
	
	
	private void callNativeCV ( Method method , Mat mat )
	{
		switch (method) 
		{   
			case ACCENTEDEDGES: 
				accentedEdges(mat.getNativeObjAddr());
				break;
			case ADDNOISE:
				addNoise(mat.getNativeObjAddr(), addNoiseValue);
				break;
			case BASRELIEF:
				basRelief(mat.getNativeObjAddr());
				break;
			case BLUR:
				blur(mat.getNativeObjAddr());
				break;
			case COLORPENCIL:
				colorPencil(mat.getNativeObjAddr());
				break;
			case CROSSHATCH:
				crosshatch(mat.getNativeObjAddr()); 
				break;
			case DIFFUSE:
				diffuse(mat.getNativeObjAddr());
				break;
			case EMBOSS: 
				emboss(mat.getNativeObjAddr());
				break;
			case FILMGRAIN:
				filmGrain(mat.getNativeObjAddr());
				break;
			case FINDEDGES:
				findEdges(mat.getNativeObjAddr());
				break;
			case GAUSSIANBLUR:
				gaussianBlur(mat.getNativeObjAddr(), gaussianValue);
				break;
			case GETEDGE:
				getEdge(mat.getNativeObjAddr());
				break;
			case GRAIN:
				grain(mat.getNativeObjAddr(),grainValue);
				break;
			case GRAPHICPENSKETCH:
				graphicPenSketch(mat.getNativeObjAddr());
				break;
			case HALFTON:
				halfTon(mat.getNativeObjAddr());
				break;
			case LAPLACIANSHARP:
				laplacianSharp(mat.getNativeObjAddr());
				break;
			case LIGHTING:
				lighting(mat.getNativeObjAddr(), lightingValueX, lightingValueY, lightingValueRadian);
				break;
			case MOREBLUR:
				moreBlur(mat.getNativeObjAddr());
				break;
			case MORELAPLACIANSHARP:
				moreLaplacianSharp(mat.getNativeObjAddr());
				break;
			case MOSIACTILES:
				mosaicTiles(mat.getNativeObjAddr(),mosaicValue);
				break;
			case MOTIONBLUR:
				motionBlur(mat.getNativeObjAddr(), motionValue);
				break;
			case NOISEBLUR:
				noiseBlur(mat.getNativeObjAddr());
				break;
			case PAINTDAUB:
				paintDaub(mat.getNativeObjAddr());
				break;
			case PATCHWORK:
				patchWork(mat.getNativeObjAddr());
				break;
			case PHOTOCOPY:
				photoCopy(mat.getNativeObjAddr());
				break;
			case SHARPENEDGE:
				sharpenEdge(mat.getNativeObjAddr());
				break;
			case SOLARIZE:
				solarize(mat.getNativeObjAddr());
				break;
			case UNSHARPENING:
				unsharpening(mat.getNativeObjAddr());
				break;   
			case WATERCOLOR:
				watercolor(mat.getNativeObjAddr());
				break;
			default:
				break;
		}
	}
	
	private native void addNoise(long addrImage, int value);								//!@변수 - ???
	private native void noiseBlur(long addrImage);										//!@변수 - 블러 크기
	private native void lighting(long addrImage, int xValue, int yValue, int radius);	//!@변수 - 원 위치, 원 반지름
	private native void accentedEdges(long addrImage);									//!변수 없음
	private native void crosshatch(long addrImage);										//!
	private native void laplacianSharp(long addrImage);									//!변수 없음
	private native void moreLaplacianSharp(long addrImage);								//!변수 없음
	private native void unsharpening(long addrImage);										//!변수 없음
	private native void sharpenEdge(long addrImage);										//!변수 없음
	private native void sketchNoise(long addrImage);										//!사용안함 -> 그래픽 펜을 위함
	private native void graphicPenSketch(long addrImage);									//!
	private native void basRelief(long addrImage);										//!변수 없음
	private native void halfTon(long addrImage);											//!변수 없음
	private native void photoCopy(long addrImage);										//!변수 없음
	private native void diffuse(long addrImage);											//! 
	private native void emboss(long addrImage);											//!
	private native void findEdges(long addrImage);										//!
	private native void solarize(long addrImage);											//!
	private native void colorPencil(long addrImage);										//!
	private native void filmGrain(long addrImage);										//!
	private native void paintDaub(long addrImage);										//!
	private native void watercolor(long addrImage);										//!
	private native void grain(long addrImage, int value);								//!변수 - ???
	private native void mosaicTiles(long addrImage, int value);							//!변수 - 타일 크기
	private native void patchWork(long addrImage);										//!
	private native void blur(long addrImage);												//!변수 없음
	private native void moreBlur(long addrImage);											//!변수 없음
	private native void gaussianBlur(long addrImage, int sigma);							//!변수 - sigma
	private native void motionBlur(long addrImage, int value);							//!변수 - 가로 or 세로 지정
	private native void getEdge(long addrImage);											//!변수 없음
	
	static{
		System.loadLibrary("SSMProject");
	}
}

